clear - очистить терминал

cd. или cd./ - текущий каталог

cd.. или cd../ - родительский каталог

cd ~ - C:\Users\YDV\

ls - вывод всех нескрытых каталогов
ls -a - вывод всех (НЕ скрытых и скрытых) каталогов и (НЕ скрытых и скрытых) файлов а также ./ ../ 
(мышкой не прокручивается)



git init - создание репозитория гит в текущем каталоге и ПОЛНОСТЬЮ ПЕРЕСОЗДАЕТ тот что есть



Задает текущие данные пользователя в репозитории гит текущего каталога
в файле .git/configt
git config user.name "NAME SURNAME" 
git config user.email user@mail.com



cat .git/configt - выводит по группам и свойствам содержимое файла .git/configt



tree -a -вывод дерева каталогов со скрытыми файлами



--system - program files/git/etc (program files/git/mingw/etc/config)
--global - YDV/.gitconfig
	if not null $XDG_CONFIG_HOME - $XDG_CONFIG_HOME/git/config
	if null $HOME/.config = ~/.config/git/config

--local - YDV/.git/config



Задает текущие данные пользователя в репозитории гит глобального ~/.gitconfig
в файле .git/configt
git config --global user.name "NAME SURNAME" 
git config --global user.email user@mail.com

cat ~/.gitconfigt - выводит по группам и свойствам содержимое файла ~/.gitconfigt



git config --unset user.name - удаляет локальную позицию
git config --unset user.name - удаляет локальную позицию

git config --remove-secton user - удаляет локальную секцию и все позиции в секции

git config --list - выводит все позиции со всех возможных конфигов



git config -h - выводи хелпник (ман) всех суб команд для команды git config

git help config - самая полная справка о конфиге в LESS многостраничном формате

LESS - программа ГИТ-ЛИСТАКЛА работает в баше
	/ - внутренняя команда поиска по регэкспу
	n - ПОИСК ВПЕРЕД
	Shift + n - ПОИСК НАЗАД
	q - вызод из листалки

git config --global core.pager 'less -RFX' - правильная настройка и запуск LESS для хелпников


АЛИАСЫ - ПСЕВДОНИМЫ комманд (искользуют для переназначения имен команд под свои)

git config --global alias.c config - переназначается только то что после alias.c в имя c
git config --global alias.c 'config --global' - тоже самое что и выше но уже команд больше


git config alias.sayhi '!echo "hello"; echo "from git"' - запускает несколько комманд через точку с запятой внутри кавычек с восклицательным знаком'! command1; command2 '



	ОЧЕНЬ ВАЖНА виндоус и линуск разница перевода строк в текстовых вайлах конфигов баша
0a - 1 байт перевода строки в линукс 1 байт равно 0-255 = 0-11111111 = 0-FF
0d 0a - тоже самое для виндоуз 0d это CR = перевод каретки 0a это LF = перевод строки (как и в юникс)
	РЕШЕНИЕ ПРОБДЕМЫ
CORD.AUTOCRLF git config --global core.autocrlf true
>true - ИЗ ГИТа вытягивается файл который правильно меняет байты отступов с линуксовских на виндоусовские (на отдаленный гит помещаются линуксовские переводы строк)
>input -ИЗ ГИТа вытягивается файл который не меняет отступы с линукс на виндоус (в гит ложится линукс переводы строк)
>false - вообще не контролируетп кроссплатформенный перевод строк как В гит так и ИЗ гита
модет быть ошибка если файл бинарный


git config --global --edit ИЛИ (-e) - соращение = VIM редактирование конфиг файла
alt + shift + : - включает команды для VIM
insert - переключает ВИМ в режим возможности печатанья втексте
:wq - выйти с VIM с сохранением
:q! - выйти с VIM без сохранения	 

git config --global core.editor  ... - задает редактор по умолчанию ... (можно задаьб что-то и кроме вим) 
	через переменные окружения GIT_EDITOR или EDITOR или VISUAL
notepad ~/.gitconfig - откроет ~/.gitconfig и будет ждать пока не кончишь редактировать, в некоторых программах надо указывать флаг -w перед путем/файлом





Аттрибуты для определения бинарный файл или текстовый	

~/progect/.gitattributes

* применить ко всем файлам (атрибут не указан, атрибут отсутствует = не тоже самое что его нет)
* text ко всем файлам применить аттрибут text без значения (без значения означает что все файлы система вопринимает как ТОЛЬКО ТЕКСТОВЫЕ)
* text=auto ко всем файлам применить аттрибут text со значением автоматического определения системой гит тектовый ли файл или бинарный по своим системным алгоритмам

*.html text - перекрывает ту команду что выше и говорит что для всех ХТМЛ файлов система должна их воспринимать как текстовый (стоит текстовый атрибут)
*.html -text - перекрывает ту команду что выше и говорит что для всех ХТМЛ файлов система должна их воспринимать НЕ как текстовый (стоит снятие "-" текстового атрибута)

*.bat text eol=crlf - задает виндоусовский перевод строк (Эквивалентно записи *.bat eol=crlf) ++МЕНЯЕТ перевод строк
*.sh eol=lf - задает линуксовский перевод строк ++НЕ МЕНЯЕТ ПЕРЕВОД СТРОК
	если eol не указан то возьмет с ~/.gitconfig core.autocrlf = true - преобр к виндовым переводам строк =input не будет, если нет в том файле то смотрит файл core.eol если и его нет то смотрит платформе, под виндоус преоб строк будет выполнено, на линукс нет
*.jpg binary -text -merge -diff - говорит что файл бинарный с точки зрения преобразования переносов строк + отключает текстовое слияние и сравнение для таких файлов

	КАК ищится файл атрибутов гитом на твоей машине?
<project>/.git/info/attributes
<project>/a/b/.gitattributes
<project>/a/.gitattributes
<project>/.gitattributes
>config: core.attributesFile = git config --global core.attributesFile ~/.gitattributes
(default)$XDG_CONFIG_HOME/git/attributes
(default)~/.config/git/attributes
/etc/gitattributes
C:\Prog Files\Git\[mingw]etc\gitattributes

git help attributes - вызывает справку об атрибутах



ИГНОРИРОВАНИЕ ГИТОМ файлов

* 
* 
* .gitignore
* #blablabla - ?комментарий
* Thumbs.db - игнорирование такого файла или директории с таким названием
* *.блабла - игнорирование всех файлов с расширением *.блабла но НЕ *.блаблаб
* *.py[co] или pyc или pyo
* *.migrate-201[5-7]* - игнор всех что кончаются на от 5 до 7 аж 0 или много раз
* *.py? = НеТ py или ДА pyo или ДА pyc
*
* ИГНОРИРОВАНИЕ ВО ВСЕХ подкаталогах имен файлов и каталогов

built/ игнорирование ИМЕННО КАТАЛОГА built во всех под каталогах и корневом каталоге проекта
/built/ - тоже самое но ТОЛЬКО в корне проекта
/built/

secret/key - игнор да docs/secret/key - нет

/*.txt - только корневые тхт

var/www*/tmp = var/www=xdfgxfg/tmp != var/wwwdfsdf/info/tmp
tmp/*/private все что годно в звездочке кроме если tmp/private | tmp/1/2/private | script/tmp/john/private

** - не заменяет имя а заменяе только путь
** - в конце игнор всей директории
**/*.log - ищет в любом пути все лог файлы
*/app/cash - только в корне
docs/**/*.html где угоднов докс все хтмл


! - игорировать все кроме чего-то
.*
!.gitignore - игнорировать все кроме .gitignore
/install/
!install/packages.xml = не работает - игнорирует всю директорию

/install/*
!install/packages.xml = работает - игнорирует всё что после директории

git check-ignore -v install/something - команда проверяет игнорируется ли файл в данном пути

> <project>/.../.gitignore - файл игнорации работает в поддиректории где он находится и все поддир от этого поддир пути
> <project>/.git/info/exclude - не передается коллегам через гитхаб, доступен только для самого юзера
> config: core.excludesFile     ~/.gitignore    git config --global core.excludesFile ~/.gitignore	>(default) $XDG_CONFIG_HOME/git/ignore		>(default)~/.config/git/ignore


подключение файлов в config include

git config include.path ... относительный путь отсчитывается от файла конфигурации ,git/config -> project/hitconfig
каждый след конфиг перезаписывает предыдущ, если мы так не хотим то git config -add include.path ../gitconfig применется именно и только к ../gitconfig 

[includeIf "gitdir:~/company/"] path = ~/company/gitconfig - кладется в глобальный конФИГ

конфиг в папке .гит не передается коллегам, а конфиг внутри проекта - передаваемый




















СОЗДАНИЕ РЕПОЗИТОРИЯ ПЕРВЫЙ ПРОЕКТ

git init - добавляет к папке в которой находится сейчас юзер ВЕРСИОНИРОВАНИЕ ГИТ - создает пустой гит репозиторий .гит - сожержит всю базу данных и основные настройки гит, чтобы удалить репозиторий нужно удалить просто папку проекта


working directory
	index HTML

GIT
	index -> index.html - хранит список файлов рабочей директории отслежуемых системой ГИТ + промежуточное хранилище изменений
	Repository - хранит всю историю разработки проекта

git status - выводит состояние проекта
git add index.html - добавит в index гита файл index.html
git commit - добавляет с index гита в Repository гита файлы которые были добавлены и отредактированы в с index гита и открывает ВИМ для комментирования изменений
	в ВИМ все что после знака #-то комментарий, нужно чтоб был хотя бы один заголовок - первая строчка, а потом через пропуск двух строк звездочки можно дописывать изменения
	После коммита 16ХЕКС - число - это часть хэш суммы проекта, а так там 40 байт (16-чных цифр)
	6 цифр через 1 строки ниже - 100644 100 - тип объекта который мы сожраняем в гит 100 - это файл 644 - права на этот файл 755 - файл исполнимый для юзера 644 не исполнимый

chmod +x index.html - меняет исполнимость файлов как тогглер, после этого гадо в индекс гит а потом в репозиторий гит опять добавлять


git config core.fileMode false - гит выставляет это при создании репозитория если файловая система линукс не поддерживает исполнимость


git update-index --chmod=+x index.html - в виндоус в индекс гита меняет бит иполнимости файлов (если надо с виндына линукс файл кинуть), после он такой может быть записан в репозиторий
git add --chmod=+x <file> -делает тоже самое но на этапе add

git show - выводит инфу о последнем коммите
git show e4A55с5 - выводит инфу о коммите с номером из 16ХЕКС (надо не менее 4хцифр)
git git --pretty=fuller - выводит больше инфы 

git commit --author='John Smith <john@me.com>' --date='...' - коммитит с указанием автора и даты в поля Author и AuthorData
	GIT_AUTHOR_NAME
	GIT_AUTHOR_EMAIL
	GIT_AUTHOR_DATE
	GIT_COMMITER_NAME
	GIT_COMMITER_EMAIL
	GIT_COMMITER_DATE
		переменные окружения для изменения данных автора и коммитера

git add . - добавляет в индекс гит что от текущем каталоге проекта и подкаталогах (кроме .гит) (ТОЛЬКО НЕ ПУСТЫЕ КАТАЛОГИ) и все что внутри него
git reset HEAD .idea - удаляет каталог .idea с индекс гит который ранее туда добавился на ветке HEAD

git add --force (или коротко -f) .idea/project.iml - исключит этот файл из гитИГНОР

git commit -m 'blablabla' добавляет с index гита в Repository гита файлы которые были добавлены в index гит без откытия ВИМ но внесения инфы в кавычках (не коммитит модификации в файле, их надо предварительно эдить помл модификации)

git commit --all (или -a) (или -m) (или -am) 'blablabla' коммитит как выше сразу добавляя в индекс модификации файлов и сразу вносит все в репозиторий гит И ТОЛЬКО для тех что уже есть в индексе (коммитит модификации в файле сразу)
	неяаня передача пути
git commit -m 'blablabla' .gitignore - комитит конкретный файл с индекс гита
	явная передача пути

ЧЕРЕЗ ЭЛИАС можно сделать и автоиндексирование всего и автокоммитирование всего что есть в проекте
	git add . добавляет все что от текущей директории .
	git add -A добавляет все что с директории корня проекта

touch gitignore - создает локальный файл gitignore 
git config --global core.excludesFile ~/.gitignore - создает глобальный файл исключения

git rm -r ... - удаляет файлы, флаг -r директории как в раб дир так в индекс гит (автомамтом добавляет индекс гит)

git rm -r --cached ... - удаляет папку только с индекс гит (но не удалит с файлами которые в статусе модификации, выдаст ошибку)

git rm -f index - игнорирует тот факт что файл в статусе модификации и удаляет его, если без -f - то выдаст ошибку, т.к. файл находится в состоянии модификации
git rm -rf - удалит папку с модифицируемым файлом
git mv index.html hello.html - переименует файл и вносит изменение имени в рабочей директории и в индекс гит атоматом







ВЕТКИ в ГИТ

гит НЕ ВСЕГДА хранит инфу о ветках в папке ~/project/.git/refs/heads/master и другие ветки

git branch - просмотр информации о ветках
git branch -v - посмотр полной информации о ветках


~/project/.git/HEAD - этот файл указывает гит репозиторию где мы находися сейчас, хранит ссыдку на текущую ветку в который мы сеячас находимся (может хранить ссылку на коммит !редко)
ВЕРШИНА ветки - это самый последний её коммит и ~/project/.git/HEAD будет указывать на неё

git branch feature - создает новую ветку feature с тем же кодом коммита что и родительская ветка (у нас это мастер) ~/project/.git/refs/heads/master, появится файл ~/project/.git/refs/heads/feature
	git branch feature [051a] [fix] - создаст ветку feature на коммите 051a или вершине ветки fix
git checkout feature - переключает на ветку feature с родительской ветки (у нас это мастер), если  И ХРАНИТ с ветки все незакомиченные изменения
	НЕВОЗМОЖНО переключать с ветки на ветку файлы в состоянии МОДИФИКАЦИИ если файлы РАЗНЫЕ по своему содержимому хоть даже на один символ!
	Если файлы одинаковые и в состоянии модификации, то ГИТ может переключатся между ветками в стостоянии "ПЛАВАЮЩЕЙ МОДИФИКАЦИИ" файла, если добавить в любой ветке "плавающюю модификации в" индекс гит, то это будет плавающий индекс гит, а если мы захотим закоммитить, то закоммитится все что в плавающем индексе только в той ветке, в которой мы находимся  
	HEAD будет ползти по нему, если вернутся обратно на мастер то HEAD будет указывать на последний комит мастера
ТОЛЬКО Commit в новой ветке сделает ветку неравной коммиту в старой родительской и сделает её полностью реально индывидуальной (он будет иметь свой собственный уникальный коммит)

* - САМАЯ ВАЖНАЯ КОММАНДА ДЛЯ ВОССТАНОВЛЕНИЯ ПРЕДЫДУЩИХ ВЕРСИЙ
* git checkout <commit|HEAD|@|@~n|@^b|####> [файлы папки]- восстановит версию ПО на момент данного коммита в гит папку и гит индекс [можно востанавливать конкретные файлы и папки]
* 	git checkout <path> - восстановить в гитпапку то что в индекс гит
* 		git checkout HEAD <path> - восстановить с репозитория гит и папку гит и в индекс гит
*

git checkout -b fix (git branch fix + git checkout fix) - создает ветку fix и тут же на неё переключает гит, все назакомиченные модификации в мастер будут также перенесены в ветку фикс, ветка Фикс = ветка Мастер = ветка HEAD

git checkout --force (сокр. -f) master - переходит на ветку мастер с дюбой другой ветки ПОЛНОСТЬЮ удаляя любые модификации файлов если обратно вернешься на старую ветку

git checkout --force (сокр. -f) [можно с или без HEAD] - просто удаляет все модификации в файлах до последнего комита в ветке (очищает индекс)

git stash - сохраняет незакомиченые изменения в проекте если надо экстренно перекл на другую ветку через флаг очистки индекса -f (это как игнорировании модификации с удалением всечто намодифицировано)
	git stash pop - возвращает на ветку измененея предварительно сохраненные в git stash обратно (можно отпопить с риском конфликтов на других ветках)

git branch -f master 5eа1 [fix] - ПЕРЕСОЗДАСТ ВЕТКУ master на указанном коммите (ветке) (нельзя запустить на той самой ветке что и действующая, надо переключится обратно) (если ветки МАСТЕР НЕТ то он её создаст с нуля на указанном коммите (ветке))
	МОЖЕТ быть выполнена если мы модифицируем файл

git checkout -B master 54a4 = как две комманды сразу "git branch -f master 54a4" + "git checkout master") - пересоздаст ветку мастер на нужном коммите (или ветке) и сразу переключит на ветку мастер НЕ через -f (может быть вызвано даже если мы находимся в самой ветке мастер)  
	НЕ МОЖЕТ быть выполнена если мы в данный момент модифицируем файл 

git checkout 154d - переключает HEAD на коммит с идентификатором 154d любые последующие коммиты будут идти как отдельная ветка от коммита идентификатора 154d 

git cherry-pick 9e28 14b1 - скопирует несколько комитов на текущую ветку, например если ты на фикс - то все комиты с данными идентификаторами станут на фикс

git checkout 54a5 (?HEAD | branch) index.html (+ n files) - переключает гит на данный коммит и помещает в индекс гит версию файла с того комита а рабочий файл меняет на версию файла в том старом комите (если есть HEAD и путь то переместит и в раб дир и в индекс гит, а только с путем из индекс гит в раб дир)
	branch = master && branch = dirname - сначала будет искать название ветки, а если нет такой ветки то будет думать что это файл (-- master - гит будет думать что это ТОЛЬКО ПУТЬ и рабоать как с путем а не веткой, можеь быть HEAD -- master)
	git reset index.html - удалит с индекс гит ранее внесенную туда старую версию файла


git log - выводит все коммиты списком (ИДкоммита,автор и дата) на данной ветке в которой ты находишся
	git log --all то же самое но по всем веткам
	git log --graph - выведит в виде графа структуру гита 
	git log --oneline - тоже самое но сокращенное
	git log master --oneline - показывает коммиты ветки мастер
		git log --all --oneline --graph - выведет структуру гита по всем веткам с сокращенной информацией коммитов

git show (? HEAD ||@ , id) показывает коммит с заданным ид коммита, с или без HEAD -показывает коммит на HEAD, @ тоже самое что и HEAD, тильды работают как для HEAD так и для id коммит так и для мастер и тд любых названий веток 
	git show HEAD~ (n times ~) || (~n) --quiet  - показывает коммит родителя HEAD, n times ~ || (~n) - показывает коммит n-го прародителя HEAD, --quiet показывает инфу но без показа изменений

git show @~:index.html - покажет содержимое файла index.html из коммита родителя не удаляя модификацию файла в текущем коммите
	git show fix:index.html - выведит содержимое index.html с вершины ветки индекс хоть на какой бы ты ветке не находился и не удалит текущую модификацию файла на данной ветке
	git show :index.html - выведит текущее содержимое файла index.html из добавленного в ИНДЕКС ГИТ
	git show :/sayBye - ищет НЕЗАВИСИМО ОТ ВЕТОК слово в файле sayBye в САМОМ СВЕЖЕМ КОММИТЕ




git merge fix - выполняет слияние веток например ветка fix выше master (который ёё далекий прародитель), после комманды вершина ветки master переместится на вершину ветки fix (просто переместит туда указатель этой ветки)
cat .git/ORIG_HEAD - вэто файле хранится идентификатор оригинальногокоммита с которой изначально перемещалась ветка мастер после комманды git merge fix
	git branch -f master 54a5 - вернет указатель ветки МАСТЕР на идентификатор коммита 54а5 если надо отменить смердживаниекогда ты знаешь ИД оригинального досмердженного коммита
	git branch -f master ORIG_HEAD - вернет указатель ветки МАСТЕР на идентификатор коммита в файле ORIG_HEAD если надо отменить смердживаниекогда ты НЕ знаешь ИД оригинального досмердженного коммита

git branch -f master fix - НЕ СРАБОТАЕТ, нельзя перемещать ветку на если ты на ней же сейчас находишся (git branch -f master - важен ИД МАСТЕР,а ты итак в мастере, нельзя на одной и той же ветке)
	git checkout -B master fix - СРАБОТАЕТ, перезоздаст ветку мастер и переместит её на вершину ветки fix (git checkout -B master - если ты был на ветке мастер, то переключение будет на мастер, так как вежен опять же таки идентификатор МАСТЕР) (НО КОММАНДА МЕРДЖ более мощная)

git branch -d fix - удалит ветку (ссылку) фикс, а коммиты останутся, БУДЕТ ОШИБКА если на тот же коммит что указывает указатель фикс не указывает любой другой именованый указатель, также ошибка, если вызывать команду для ветки с именем Х находясь на ветке с тем же именем Х

git branch -D feature - удалит ветку с указателем feature и все её коммиты даже если на коммит на который указывает указатель фетки фичер не указывает указатель любой другой ветки
	git branch feature 2с11 - восстановит ветку feature, для этого надо указать коммит на который в последний раз указывала ветка фичер


cat .git/logs/HEAD - папка хранит файлы логов любых изменений, файлы - в них записи логов любых изменений (название файла - это имя указателя ветка)

git reflog master (?feature, ?fix) (без аргументо для HEAD) - выведит лог любых телодвижений на указанном именованом указателе ветки (у нас это МАСТЕР git reflog master) 
	git reflog --no-decorate - выведит рефлог без дополнительных ссылок

git branch feature HEAD@{6} (windows powershall 'HEAD@{6}')- восстановил удаленную ветку фичер из файла reflogов гита для указателя коммитов HEAD (его файла логов действий) с 6-й строки, подставить туда соответствующий идентификатор (6-я строка от ИНИТИАЛ КОММИТ в файле)  

git reflog shor - это алиас для комманды git log --oneline -g, сделает т оже самое что и git reflog master (?feature, ?fix) (без аргументо для HEAD)

git reflog --date=iso - тоже самое что и git reflog master (?feature, ?fix) (без аргументо для HEAD) только выводит дату телодвижения на ветке в формате ИСО

git branch feature HEAD@{'2017-09-14 10:23:15 +0200'} - тоже самое что и git branch feature HEAD@{6} но теперь найдет не по номеру строки в файле а по дате телодвижения (если дата неточная то ищет максимально приближенную)
 	если коммит достижим, то запись в рефлоге ранится 90 дней, если НЕДОСТИЖИМ 30 дней gc.relogExpire="90 days ago" gc.relogUnreachableExpire="30 days ago"

git checkout @{-1} переключит HEAD на предыдущую ветку с которой был чекаут на данную (ищет это переключание в файле рефлогинга HEAD) если ветка с которой мы переключались была удалена - то выведит ошибку
	git checkout @{-3} - тоже самое но на 3 чекаута назад
	git checkout - = git checkout @{-1}

git gc - garbage collector - удалит недостижимые коммиты и проведет оптимизацию гита
	gc.pruneExpire="2 weeks ago" - через это время будут удалены недостижимые коммиты, если их нема в рефлогах

git fsck --unreachable - выводит список всех недостижимых объектов гит

git filter-branch - заменяет коммиты ветки на новые которые получены из старых путем добавления фильтра (фильтр задается в опциях),а старые коммиты при этом соотв останутся недостижимыми
	BFG - скачиваемая изинета утилита для манипуляций как выше

git reflog expire --expire=now --all - очищает файлы в reflog ГИТА --expire=now до сейчас --all - применит ко всем рефлогам
	git gc --prune=now - удалить с гита весь мусор переопределив gc.pruneExpire насейчас 



ТЕГИ
ЛЁГКИЕ ТЕГИ
git tag v1.0.0 1913 (по умолчанию HEAD) - создаст тег v1.0.0 указывающий на коммит 1913 или если без ИД то HEAD

git branch MyBranch v1.0.0

git tag -contains 54a4 - выведит тег что указывает на коммит с ид 54а4
git tag -n1 (N) - выведит список тегов и инфу о коммитах на этих тегах в количестве N строк после флага -n

git show v1.1.0 || git log --oneline v1.1.0 - выводит историю разработки начиная от данного тега

git tag -n -l 'v1.1*' выведит список теков и инфу по ним по маске после -l 'blabla' 

git tag -d v1.1.0 v1.0.0 - удалит тег сназванием v1.1.0 и v1.0.0

АННОТИРОВАННЫЕ ТЕГИ

git tag -a v1.0.0 1913 - создаст тег с инфой (надо инфу будет вводить через ВИМ)
	git tag a -m 'Version 1.0.0' v1.0.0 1913 - тоже самое без ВИМА но с инфой после -m

git describe 1913 - выводит тег ближайший к данному коммиту [HEAD without args] (+ указывает н-хопов к нему и g+ИД коммита на котором мы стоим) 

git archive -o /tmp/v.1.1.0-2-g2c11f12.zip HEAD - заархивирует в путь после о нужный коммит (тут тот что под HEAD)
	cd tmp
	unzip v.1.1.0-2-g2c11f12.zip - разархивирует обратно



diff


master> git diff master feature Что по сравнению с master сделано в ветке feature 
	diff -git a/index.html (- master) b/index.html (- feature)


@@ -5,14 (- from string #5 from master count 14 string) +5,10 (- from string #5 from feature count 10 string)  @@ - HEADER OF HUNK

- from master
+ to masert
= feature

	master> git diff master..feature = master> git diff master feature
		master> git diff master...feature =  Что по сравнению с в ветке master НА КОММИТЕ где сделано ответвление на ветку feature сделано в ветке feature
			master> git diff 2fad = HEAD against 2fad






v2.0> git cherry-pick D - создаст коммит (diff D от D~ - то есть все строки под + и -) = X diff E что = коммит вершины ветки v2.0 = D' - наш целевой коммит













git diff --cached


~./.bash_profile
alias npp='notepad++.exe -multiInst -nosession'



git help config
git help -a
git config --global --list
git config --global user.name "YDV"
git config --global user.email "YDV.SVARTVIND@gmail.com"
cat ~/.gitconfig
git config --global core.editor "notepad++.exe -multiInst -nosession"
git config --global -e = -e editing config file

git config --global merge.tool p4merge
git config --global mergetool.p4merge.path "c:\Program Files\Perforce\p4merge.exe"
git config --global mergetool.prompt false

git config --global diff.tool p4merge
git config --global difftool.p4merge.path "c:\Program Files\Perforce\p4merge.exe"
git config --global difftool.prompt false


INSIDE GIT
git mv example.txt demo.txt - переименование файла и индексация этого факта
git rm demo.txt - удление файла и индексация этого факта


BESIDE GIT

touch myfile.txt = create new empty file
mv myfile.txt myfile.md = rename file
git add -U - add to stanging area all updates only (not rename or new files [Untracked])
git add -A - add untracked adn update files (new or renamed)

git reset --soft <commit|branch|tag>- просто поменяет указатель гит не трогая Директорию гит и индекс гит
git reset --soft <commit|branch|tag>- просто поменяет указатель гит не трогая Директорию гит но очищая индекс гит
git reset --hard <commit|branch|tag>- просто поменяет указатель гит меняя директорию на то что в указанном коммите и гит но очищая индекс гит
git reflog + git checkout HEAD@{3}


git init somename
git checkout filename - удалить с индекс гит файлн filename
git checkout -- filename - удалить изменения в файлн filename

git remote add origin https://github.com/jasongtaylor/demo.git
git remote -v
git push -u origin master --tags (-u = отслеживать ветку)

ls -al

rm -rf ~/something

git clone git@github.com:jasongtaylor/demo.git website

git push origin master

git push - до ГИТ 2.0 это означало что гит запушит все изменения по всем отслеживаемым веткам, после гит 2 если ты на ветке локал-мастер и она отслеживаема то запушина будет только она а остальные отслеживаемые ветки запушены не будут
git config --global push.default matching = before 2.0
git config --global push.default simple = after 2.0
git fetch


*важная секция PULL ПУЛЛИНГА
*
* git pull = git fetch + git merge ГИТ ПУЛЛ всегда пулит так: если ты на ветке с именем мастер, то он МЕРДЖИТ на ветку мастер с ветки ТОЛЬКО с таким же именем мастер удаленки, если её нет - будет ошибка читай ниже
*	git pull <remote> <branch> - ЭТО ПОЛНЫЙ ФОРМАТ комманды, она тупо делает ФЕТЧ репозитория и мерджит с удаленки remote ветку branch на ветку на которой мы сейчас находимся







*важная секция PUSH ПУШИНГА
*
*(remove-ipmsum) website $ git push -u origin remove-ipsum = -u поставит отслеживание текущей ветки с отдаленной -u, push на текущей ветке затолкает изменения с текущей ветки на локалке в ветку remove-ipsum на отдаленке на которую указывает указатель origin 
	
* НАША ВЕТКА $ git branch -u origin/serverfix - поставит отслеживание НАША ВЕТКА с веткой serverfix
Если мы переключимся на мастер с другой ветки, то git pull будет пулить с отдаленки мастер только на мастер локалки, если мы хотим что пулило по всем веткам автоматом без переключения веток, надо в ГИТ КОНФИГ в секции [push] поставть параметр default = на matching 
git pull --all сделает тоже самое что и выше по всем отслеживаемым веткам
git push origin :remove-ipmsum - удалит ветку как глобалку когда мы пушим (А НЕ фетчим) remove-ipmsum - точное имя удаляемой ветки
git push origin remove-ipmsum - скопирует локальную ветку remove-ipmsum как глобалку remove-ipmsum когда мы пушим (А НЕ фетчим)
git push origin MySomeBranchName:remove-ipmsum - скопирует локальную ветку как глобалку когда мы пушим (А НЕ фетчим) под другим именем локальной ветки [(MySomeBranchName = эту локальную ветку мы можем обозвать как угодно]:[remove-ipmsum - это имя глобальной ветки]






* важная секция ПУЛЛ РЕКВЕСТ неразрешимость
*
*Пулл-реквест - ЭТО ВСЕГДА СМЕРДЖИВАНИЕ С ГЛАВНОЙ ВЕТКОЙ проекта на гит репозитории любой внезапно появившейся новой ветки от любого другого источника
*	Пулл реквесты бывают смердживаемыми (закрываемыми в гитхабе) и несмердживаемыми (незакрываемыми в гитхабе) - это такие реквесты у которых разные рефлоги (когда мы пытаемся впихнуть левый ветки с левых репозиториев)
* Неразрешимые пулл-реквесты можно разрешить ЛОКАЛЬНО 
* вот как это делается
*
* (master) website $git merge remove-ipmsum - ЛОКАЛЬНЫЙ ПУЛЛРЕКВЕСТ [означает ВСЕГДА ВМЕРЖИТЬ в master remove-ipmsum] (смерджит remove-ipmsum удаленки (перед этим её надо спулить из удаленки в локалку) с мастером на локалке (а потом мы это пушим обратно в отдаленку что также стало смерджено и на удаленке)\
* (master) website $git push - все запушит после смердживания ПУЛЛРЕКВЕСТА (мастер в местер удаленки)
*
*
* после этого сервак уже не будет кричать зеленой кнпочкой СМЕРДЖИ этот пуллреквест
* на ГИТХАБЕ несмержживаемые пуллреквесты абсолютно неразрешимы! только локально! 




git branch -a покажет все ветки на локалке в том числе и отдаленные
git branch -d remove-ipmsum - удалит ветку как локальнку
git fetch -p (--prune) - удалит ветку как глобалку когда мы фетчим (А НЕ ПУШИМ) ЕСЛИ мы на гитхабе ветку удалили, то чтоб локалка об этом узнала это и делают 


Можно просто переключится на удаленную ветку (если она одна уникальная для всех репозиториев) просто сделав git checkout RemoteBranchName - будет автоматом создана локадбная отслеживаемая ветка с таким же именем
если ветки на нескольких отдаленках имеют одинаковое имя и ты на них чекаутишся, то придется создавать новую ветку локально и синхронизировать её с отдаленкой, если ветка уникальна по имени для всех отдаленок, то можно не создавать локальную ветку, гит сам удачно переключит HEAD на указанную удаленную ветку И создаст автоматом отслеживаемую локальную ветку с одним и тем же именем и сразу же на неё переключит
	чтобы синхронизировать $ git checkout -b MyAnyBranchName origin/serverfix (если хочешь отличное имя)
	$ git checkout --track origin/serverfix (если не хочешь отличное имя)
		для обоих случаев создаст локальную ветку к соотв именем
$ git branch -vv - . Отобразится список ваших локальных веток с дополнительной информацией, включая то, какая из веток отслеживается, и если локальная ветка опережает, отстает или равняется относительно основной ветки.




git pull --rebase - если ты спулил отдаленку на локалку, потом ты сделал ОДИН отдельный коммит новый на локалке и один на глобалке - то просто pull сделает классический мердж двух веток, а если с ребейс - то сделает перебазирование того коммита что на серваке прямо перед твоим коммитом который будет считатся последнее
	это означает что наш локальный коммитик что на врешинке НЕ БУДЕТ ХРАНИТЬ ИЗМЕНЕНИЯ с коммитика ниже что на серваке 
	git push - для того чтобы наш новый коммитик отправился на отдаленку


	ТЭГИ 
git push origin stable - отправит тег stable на удаленный сервер
git push --tags
git tag -d ourtag - удалить локальный тег ourtag (нельзя удалить с удаленки по схеме fetch ==prune)
git push origin :ourtag - удалит тег на удаленке
git tag -f unstable 412a - пересоздаст тег на нужном коммите
git push --force origin ourtag - пересоздаст тег на нужном коммите на удаленке
git pull - выгрузит теги из отдаленки в локалку


Git pull request fork
git remote add upstream <URL> 
git pull upstream master
git push origin master

Issue $4
commit -m "Ignore Mac OS temp files, close #4" - обратить внимание на close #4 закроет Issue под репозиторием #4 - #4 - это ассоциация для Issue - работает как хеш марка привязчик, используется и реализуется вкомментариях Issues #ID

billy.com - укротитель ссылок
http://www.initializr.com/ - быстростроитель сайтов

git fetch -all - выгрузит все удаленные репозитории





https://zbporn.com/albums/420608/marry-bardot-aka-marie-claude-bourbonnais-sheer-temptation/
https://zbporn.com/albums/420608/marry-bardot-aka-marie-claude-bourbonnais-sheer-temptation/image9997208/
https://zbporn.com/albums/230915/marie-claude-bourbonnais-in-gas-chamber/
https://ru.xhamster.com/photos/gallery/marry-bardot-aka-marie-claude-bourbonnais-latex-erotica-1590218
https://ru.xhamster.com/search/photos?q=marie+claude+bourbonnais
https://fuskator.com/search/Marie+Claude+Bourbonnais/
https://ru.redtube.com/gallery?search=marie+claude+bourbonnais
http://erooups.com/tag/marie-carle


https://ru.xhamster.com/search/photos?q=olga+shkabarnya&p=17
https://ru.xhamster.com/photos/gallery/olga-chkabarnia-russian-whores-real-id-4379434
https://www.imagefap.com/pictures/6177244/I-want-fuck-olga?gid=6177244&view=2
https://www.imagefap.com/pictures/6149228/The-Olga-Blow
https://www.imagefap.com/pictures/7500996/Funtik-aka-Olia-or-Olga-S
https://www.imagefap.com/pictures/7319094/Olga-Kobzar


DiFF - делайется в пулл-реквест

в выпадающем списке выбора веток набрать

master@{3days} или year-month-day
HEAD@{3} <=> HEAD^


Важная секция git remote

git remote add [имя ссылки на удаленный репозитория] [url] - Добавление удаленных репозиториев
	извлечет указатели всех удаленных веток

git remote show [имя ссылки на удаленный репозитория] - Просмотр удаленных репозиториев

git remote rename pb paul - переименование ссылки на удаленный репозиторий
	Имеет смысл упомянуть, что эта команда умеет менять и имена удаленных веток.
		Теперь к ветке pb/master нужно обращаться по имени paul/master 
git remote rm paul - удаление ссылки на удаленный репозиторий


Важная секция git clone

при клонировании с github - будет всегда создаватся локальная ветка с именем как у базовой ветки

git clone [url] - Клонирование репозитория 
git clone [url] [name] - Эта команда делает то же самое, что и предыдущая, но все файлы оказываются в папке mylibgit

git clone http://blabla/blala.com -o ololo - склонирует не с веткой по умолчанию с именем мастер а с именем ololo
	при клонировании удаленная ветка origin/master будет всегда автоматом создавать локальную ветку master указывающую туда же куда указывает удаленная 
	клонирование всегда делает имя переменной удаленного репозитория origin

Важная секция ФОРМАТ ВЕТКИ

(имя ссылки на удаленный репозитория)/(ветка)
	origin/master
	origin/iss53

Важная секция git fetch 

КАЖДЫЙ fetch с НОВОГО РЕПОЗИТОРИЯ фетчит его в НЕЗАВИСИМЫЙ ГРАФ в самый низ. КАЖДЫЙ НЕЗАВИСИМЫЙ ГРАФ репозитория несвязан с другими незаисимыми графами других репозиториев, для связывания см git секцию git merge ***

ПО УМОЛЧАНИЮ git fetch БЕЗ ПАРАМЕТРОВ всегда выгружает только удаленный репозиторий с ИМЕНЕМ origin

$ git fetch [имя ссылки на удаленный репозитория] - Извлечение данных из удаленных репозиториев

	Переключение укзателя удаленных [origin/ветка] веток локально невозможно, они переключаются только при подключения к серверу коммандой fetch

git fetch origin - выгрузит все указатели удаленных веток с сервера origin = origin/somebranch1 origin/somebranch2 .. origin/someranch3
git fetch teamone - выгрузит все указатели удаленных веток с сервера teamone = teamone/somebranch1 teamone/somebranch2 .. teamone/someranch3



* переименование на локалке репозитория если же переименовали на гитхабе
* git remote set-url origin - git@github.com:jasongtaylor/demo.git - переименует имя проекта на который ссылается указатель origin
git remote show origin - покажет инфу о всем что есть на отдаленном репозитории с указателем origin

	ЕСЛИ мы постоянно меняет ссыклу git remote set-url origin для fetch то гит-хаб помнит максимум 3 ссылки и на 4 и т.д. будет перефетчивать фетч последнего set-url
	в последний рефетч гит будет форсить все ветки с предыдущих рефетчей


Важная секция git push

git push [имя ссылки на удаленный репозитория] [ветка] - Отправка данных из локальной ветки в удаленный репозиторий в удаленную ветку под одним и тем же именем
	git push [имя ссылки на удаленный репозитория] +[ветка] - тоже самое но без проверки fast-forward = git push -f [имя ссылки на удаленный репозитория] [ветка] - полностью перепишит удаленную ветку тем что в неё пушится
git push [имя ссылки на удаленный репозитория] [локал ветка|коммит|тег]:[удал ветка] -  Отправка данных из локальной ветки [локал ветка|коммит|тег] в удаленный репозиторий в удаленную ветку [удал ветка]
	git push [имя ссылки на удаленный репозитория] +[локал ветка|коммит|тег]:[удал ветка] - тоже самое но без проверки fast-forward = git push -f [имя ссылки на удаленный репозитория] [локал ветка|коммит|тег]:[удал ветка] - полностью перепишит удаленную ветку тем что в неё пушится

	git push -f как и + ПОЛНОСТЬЮ переписывает то что на удаленной ветке тем что мы туда в неё пушим! Это фактически единственный РЕАЛЬНЫЙ удаленный REBASE для удаленных веток
	пушить можно и теги и коммиты

git push [имя ссылки на удаленный репозитория] :[удал ветка] - удаление отдаленной ветки [удал ветка]
git push [имя ссылки на удаленный репозитория] [имя тега] - отправка тега в удаленный репозиторий

git push origin serverfix = git push origin serverfix:serverfix - отправит данные с локальной ветки serverfix на удаденную ветку serverfix
	Это в некотором роде сокращение. Система Git автоматически превращает имя ветки
	serverfix в запись refs/heads/serverfix:refs/heads/serverfix , что означает
	«возьмите мою локальную ветку serverfix и используйте для обновления удаленной ветки serverfix».

git push origin serverfix:awesomebranch - В этом случае содержимое локальной ветки serverfix будет передано в ветку awesomebranch на удаленном сервере.


	git config --global credential.helper cache - *
	*	Каждый раз вводить свой пароль не нужно. Если для отправки данных вы используете
		протокол HTTPS, сервер Git будет просить вас указать имя пользователя и пароль для
		проверки прав доступа. По умолчанию эту информацию предлагается ввести в терминале, 
		чтобы сервер мог сообщить вам, имеете ли вы право отправлять ему данные.
		Чтобы не делать этого при каждой отправке, настройте «кэш учетных данных». Проще
		всего несколько минут держать данную информацию в памяти, что легко достигается данной командой


	* * * если текущая ветка отслеживает удаленную
[текущ локал ветка = HEAD] $ git push = git push [удаленн сервер отслеживаемый текущ локал ветка = HEAD] [текущ локал ветка]:[удаленная ветка что отслеживается]

[текущ локал ветка = HEAD] git push -u origin master - [текущ локал ветка = HEAD] будет отслеживать master 
	следующий push на этой ветке может быть без агрументов если только не удалить отслеживание

git commit --allow-empty -m 'EMPTINESS COMMIT' - создаст абсолютно пустой коммит который можно затолкнуть в GitHub для тотальной чистки репозитория на определенной ветке

Важная секция git branch

git branch - покажет только локальные ветки
git branch -r - покажет только удаленные ветки
git branch -a - покажет локальные и удаленные ветки
git branch -v - покажет локальные ветки и коммиты на которые они указывают с инфой о коммитах локальной и удаленные ветки
git branch -vv - покажет локальные ветки и коммиты на которые они указывают + покажет инфу об отслеживании и/или насколько шагов локал ветка удалена от отслеживаемой + с инфой о коммитах локальной и удаленные ветки
git branch -avv - комбинированное git branch -a, git branch -vv
[HEAD -> some commit|branch|tag] $ git branch --merged - для просмотра веток, объединенных с текущей веткой [HEAD -> somebranch], оставляют в списке только те ветки, которые вы слили с текущей веткой.
[HEAD -> some commit|branch|tag] $ git branch --no-merged - для просмотра веток, объединенных с текущей веткой [HEAD -> somebranch], оставляют в списке только те ветки, которые вы слили с текущей веткой.
[HEAD -> some commit|branch|tag] $ git branch [somebranch] --merged - то же самое не для текущей ветки а для ветки [somebranch]
[HEAD -> some commit|branch|tag] $ git branch [somebranch] --no-merged - то же самое не для текущей ветки а для ветки [somebranch]
	все эти комманды можно комбинировать --merged --no-merged - всегда как флаг должны идти последними!

создание неотслеживаемых локальных веток

* * * НЕЛЬЗЯ СОЗДАТЬ ВЕТКУ находясь на голом репозитории после git init!

[HEAD -> some commit|branch|tag] $ git branch [ветка] - создание локальной ветки [ветка] на текущей позиции HEAD, нельзя создать ветку [ветка] с тем же именем что и текущая или если имя занято, для занятых имен см. -f
[HEAD -> some commit|branch|tag] $ git branch [ветка] [commit|branch|tag] - создание локальной ветки [ветка] на позиции [commit|branch|tag], нельзя создать ветку [ветка] если имя занято, для занятых имен см. -f
[HEAD -> some commit|branch|tag] $ git branch -f [ветка] - (пере)создание ветки [ветка] на текущей позиции HEAD (нельзя вызвать находясь на той же ветке), удаляет ветку со старой позиции т.к. нельзя создать две ветки с одинаковым именем
[HEAD -> some commit|branch|tag] $ git branch -f [ветка] [commit|branch|tag] - (пере)создание ветки [ветка] на позиции [commit|branch|tag] (нельзя вызвать находясь на той же ветке), удаляет ветку со старой позиции т.к. нельзя создать две ветки с одинаковым именем
	git branch НЕ ТРОГАЕТ МОДИФИКАЦИИ
	git branch -f НЕ ТРОГАЕТ МОДИФИКАЦИИ

Создание локальных веток отслеживающих локальные --track

* * * --track комманда создает новую ветку с нуля (обратить внимание *!!!) передает 

[HEAD -> !!!=ONLY branch] $ git branch --track [имя создаваемой ветки] - создаст локальную отслеживаемую ветку с именем [имя создаваемой ветки] на текущей позиции [HEAD -> ONLY branch], [имя создаваемой ветки] отслеживает ветку на текущей позиции [HEAD -> ONLY branch]
	*!!!=если [имя создаваемой ветки] уже где-то существует, то будет ошибка, используем комманду ниже
[HEAD -> !!!=ONLY branch] $ git branch -f --track [имя (пере)создаваемой ветки] - пересоздаст локальную отслеживаемую ветку с именем [имя (пере)создаваемой ветки] на текущей позиции [HEAD -> ONLY branch], [имя (пере)создаваемой ветки] отслеживает ветку на текущей позиции [HEAD -> ONLY branch] (нельзя вызвать находясь на той же ветке), удаляет ветку со старой позиции т.к. нельзя создать две ветки с одинаковым именем
[HEAD -> some commit|branch|tag] $ git branch --track [имя создаваемой ветки] [имя отслеживаемой ветки !!! ONLY branch] - создаст локальную отслеживаемую ветку с именем [имя создаваемой ветки] на позиции [имя отслеживаемой ветки], [имя создаваемой ветки] отслеживает ветку на позиции [имя отслеживаемой ветки]
	*!!!=если [имя создаваемой ветки] уже где-то существует, то будет ошибка, используем комманду ниже
[HEAD -> some commit|branch|tag] $ git branch -f --track [имя (пере)создаваемой ветки] [имя отслеживаемой ветки !!! ONLY branch] - пересоздаст локальную отслеживаемую ветку с именем [имя (пере)создаваемой ветки] на позиции [имя отслеживаемой ветки], [имя (пере)создаваемой ветки] отслеживает ветку на позиции [имя отслеживаемой ветки] (нельзя вызвать находясь на той же ветке), удаляет ветку со старой позиции т.к. нельзя создать две ветки с одинаковым именем
	*!!!=если [имя (пере)создаваемой ветки] такое же как текущая ветка на которой находишся, то будет ошибка, -f не пересоздает текущие ветки

Передча отслеживания ветке --set-upstream-to -u

* * * --set-upstream-to команда НИКОГДА НЕ СОЗДАЕТ новую ветку а только передает отслеживание между существующими ветками

[HEAD -> !!!=ONLY branch] $ git branch --set-upstream-to [имя ветки которая будет отслеживаема !!!=никогда не текущая "HEAD -> !!!=ONLY branch"] - текущая ветка [HEAD -> !!!=ONLY branch] будет отслеживать [имя ветки которая будет отслеживаема !!!=никогда не текущая HEAD -> !!!=ONLY branch]
	-f - этот флаг ничего не означает, сделает тоже самое что выше
	*!!!=если [имя ветки на которую передаем отслеживание и/или "!!!=никогда не текущая HEAD -> !!!=ONLY branch"] не существует, то будет ошибка даже с -f, т.к. --set-upstream-to команда НИКОГДА НЕ СОЗДАЕТ новую ветку а только передает отслеживание между существующими ветками
[HEAD -> some commit|branch|tag] $ git branch --set-upstream-to [имя ветки которая будет отслеживаема] [имя ветки которая будет отслеживать] - ветка [имя ветки которая будет отслеживать] будет отслеживать [имя ветки которая будет отслеживаема]
	-f - этот флаг ничего не означает, сделает тоже самое что выше
	*!!!=если [имя ветки которая будет отслеживаема] или [имя ветки которая будет отслеживать] не существует, то будет ошибка даже с -f, т.к. --set-upstream-to команда НИКОГДА НЕ СОЗДАЕТ новую ветку а только передает отслеживание между существующими ветками

Удаление отслеживания у ветки --unset-upstream
	
[HEAD -> some commit|branch|tag] $ git branch --unset-upstream [имя ветки у корой удаляем отслеживание] - удалит отслеживание у ветки [имя ветки у корой удаляем отслеживание]
	

Удаление локальных веток

git branch -d [ветка] - удаление локальной ветки в состоянии --merged
git branch -D [ветка] - удаление локальной ветки в состоянии --no-merged

Удаление удалённых веток на локальном репозитории

git branch -rd - удалит удаленную ветку на локальном репозитории
git branch --prune - удалит удаленную ветку на локальном репозитории если была уже удалена на удаленном репозитории 

Удаление удалённых веток на удаленном репозитории

Как удалять удаленных ветоки на удаленных репозиториях см git push

$ git push origin --delete serverfix - ликвидация ветки на удаленном сервере origin


*******************
Важная субcекция создания git branch по отношениюк удаленному репозиторию
*******************
При переходе checkout на origin/master - перейдёт в DETACH HEAD === на коммит на котором находится origin/master
При переходе checkout на master (если мастер локально не существует) - создаст master отслеживающий origin/master
При переходе checkout на master (если мастер локально существует) - перейдет на локальный master
* в состоянии в DETACH HEAD
*	DETACH HEAD === [commit #ID] <origin/master, origin/HEAD> (* * * commit #ID === НАШ КОММИТ)
	+
	DETACH HEAD === [HEAD НЕ РАВЕН commit #ID или HEAD РАВЕН commit #ID] $ git branch [ветка] (ОПЯТЬ как выше * * * commit #ID === НАШ КОММИТ)
	создаст локальную ветку [ветка] НЕОТСЛАЖИВАЕМУЮ с origin/master

	DETACH HEAD === [HEAD НЕ РАВЕН commit #ID или HEAD РАВЕН commit #ID] $ git branch [ветка] [commit|branch|tag] (ОПЯТЬ как выше * * * commit #ID === НАШ КОММИТ)
	создаст локальную [commit|branch|tag] на позиции [ветка] НЕОТСЛАЖИВАЕМУЮ с origin/master (у tag или commit отслеживания не бывает)	

	
Создание локальных веток отслеживающих удаленные ветки

[HEAD -> some commit|branch|tag] $ git branch [ветка] [имя ссылки на удаленный репозитория/имя удаленной ветки] - создание отслеживаемой локальной ветки [ветка] на позиции [имя ссылки на удаленный репозитория/имя удаленной ветки]
		!!! НЕ БЫВАЕТ ВАРИАНТА [HEAD -> some commit|branch|tag] $ git branch [ветка] [commit|branch|tag] origin/somebranch или [HEAD -> some commit|branch|tag] $ git branch [ветка] origin/somebranch [commit|branch|tag]
	* ТОЛЬКО [имя ссылки на удаленный репозитория/имя удаленной ветки] НИКОДА [имя удаленной ветки]
	*!!!=если имя ветки [ветка] имя уже где-то существует, то будет ошибка, используем комманду ниже
[HEAD -> some commit|branch|tag] $ git branch -f [ветка] [имя ссылки на удаленный репозитория/имя удаленной ветки] - пересоздание отслеживаемой локальной ветки [ветка] на позиции [имя ссылки на удаленный репозитория/имя удаленной ветки] (нельзя вызвать находясь на той же ветке), удаляет ветку со старой позиции т.к. нельзя создать две ветки с одинаковым именем
	* ТОЛЬКО [имя ссылки на удаленный репозитория/имя удаленной ветки] НИКОДА [имя удаленной ветки]
		!!! НЕ БЫВАЕТ ВАРИАНТА [HEAD -> some commit|branch|tag] $ git branch -f [ветка] [commit|branch|tag] origin/somebranch или [HEAD -> some commit|branch|tag] $ git branch -f [ветка] origin/somebranch [commit|branch|tag]

Создание локальных веток отслеживающих удаленные ветки --track

[HEAD -> some commit|branch|tag] git branch --track [имя создаваемой ветки] [имя ссылки на удаленный репозитория/имя удаленной ветки] - создаст локальную отслеживаемую ветку с именем [имя создаваемой ветки] на позиции [имя ссылки на удаленный репозитория/имя удаленной ветки]
	* ТОЛЬКО [имя ссылки на удаленный репозитория/имя удаленной ветки] НИКОДА [имя удаленной ветки]
	*!!!=если [имя создаваемой ветки] уже где-то существует, то будет ошибка, используем комманду ниже
[HEAD -> some commit|branch|tag] git branch -f --track [имя (пере)создаваемой ветки] [имя ссылки на удаленный репозитория/имя удаленной ветки] - пересоздаст локальную отслеживаемую ветку с именем [имя (пере)создаваемой ветки] на позиции [имя ссылки на удаленный репозитория/имя удаленной ветки] (нельзя вызвать находясь на той же ветке), удаляет ветку со старой позиции т.к. нельзя создать две ветки с одинаковым именем
	* ТОЛЬКО [имя ссылки на удаленный репозитория/имя удаленной ветки] НИКОДА [имя удаленной ветки]

*!!! * * * НЕ БЫВАЕТ

[HEAD -> some commit|branch|tag] git branch --track [имя ссылки на удаленный репозитория/имя удаленной ветки] [имя создаваемой ветки] - ошибка, [имя создаваемой ветки] которая будет отслеживаема не существует
[HEAD -> some commit|branch|tag] git branch -f --track [имя ссылки на удаленный репозитория/имя удаленной ветки] [имя создаваемой ветки] - ошибка, [имя создаваемой ветки] которая будет отслеживаема не существует
[HEAD -> some commit|branch|tag] git branch --track [имя ссылки на удаленный репозитория/имя удаленной ветки] [имя ссылки на удаленный репозитория/имя удаленной ветки] - создаст локальную ветку с именем [имя ссылки на удаленный репозитория/имя удаленной ветки] которая будет отслеживать ветку [имя ссылки на удаленный репозитория/имя удаленной ветки] и только если ветка второго опренда существует
[HEAD -> some commit|branch|tag] git branch -f --track [имя ссылки на удаленный репозитория/имя удаленной ветки] [имя ссылки на удаленный репозитория/имя удаленной ветки] - создаст локальную ветку с именем [имя ссылки на удаленный репозитория/имя удаленной ветки] которая будет отслеживать ветку [имя ссылки на удаленный репозитория/имя удаленной ветки] и только если ветка второго опренда существует, (нельзя вызвать находясь на той же ветке, то есть с именем [имя ссылки на удаленный репозитория/имя удаленной ветки]), удаляет ветку со старой позиции т.к. нельзя создать две ветки с одинаковым именем

Передча отслеживания ветке --set-upstream-to (передается только локальным, удаленные не могут ничего отслеживать) -u

[HEAD -> !!!=ONLY branch] $ git branch --set-upstream-to [имя ссылки на удаленный репозитория/имя удаленной ветки] - текущая ветка [HEAD -> !!!=ONLY branch] будет отслеживать [имя ссылки на удаленный репозитория/имя удаленной ветки]
	* ТОЛЬКО [имя ссылки на удаленный репозитория/имя удаленной ветки] НИКОДА [имя удаленной ветки]
	-f - этот флаг ничего не означает, сделает тоже самое что выше
	*!!!=если [имя ссылки на удаленный репозитория/имя удаленной ветки] не существует, то будет ошибка даже с -f, т.к. --set-upstream-to команда НИКОГДА НЕ СОЗДАЕТ новую ветку а только передает отслеживание между существующими ветками
[HEAD -> some commit|branch|tag] $ git branch --set-upstream-to [имя ссылки на удаленный репозитория/имя удаленной ветки] [имя ветки которая будет отслеживать] - ветка [имя ветки которая будет отслеживать] будет отслеживать [имя ссылки на удаленный репозитория/имя удаленной ветки]
	* ТОЛЬКО [имя ссылки на удаленный репозитория/имя удаленной ветки] НИКОДА [имя удаленной ветки]
	-f - этот флаг ничего не означает, сделает тоже самое что выше
	*!!!=если [имя ссылки на удаленный репозитория/имя удаленной ветки] или [имя ветки которая будет отслеживать] не существует, то будет ошибка даже с -f, т.к. --set-upstream-to команда НИКОГДА НЕ СОЗДАЕТ новую ветку а только передает отслеживание между существующими ветками

*!!! * * * НЕ БЫВАЕТ

[HEAD -> some commit|branch|tag] $ git branch --set-upstream-to [имя ветки которая будет отслеживаема] [имя ссылки на удаленный репозитория/имя удаленной ветки которая будет отслеживать] - не существует локальной ветки с именем [имя ссылки на удаленный репозитория/имя удаленной ветки которая будет отслеживать], а глобальная не воспринимается всеръёз
[HEAD -> some commit|branch|tag] $ git branch --set-upstream-to [имя ссылки на удаленный репозитория/имя удаленной ветки которая будет отслеживаема] [имя ссылки на удаленный репозитория/имя удаленной ветки которая будет отслеживать] - не существует локальной ветки с именем [имя ссылки на удаленный репозитория/имя удаленной ветки которая будет отслеживать], а глобальная не воспринимается всеръёз

Удаление отслеживания у ветки --unset-upstream (удаляется только локальным, удаленные не могут ничего отслеживать)

[HEAD -> some commit|branch|tag] $ git branch --unset-upstream [имя ветки у корой удаляем отслеживание] - удалит отслеживание у ветки [имя ветки у корой удаляем отслеживание]

Важная секция git checkout

-M [HEAD -> some commit|branch|tag] $ git checkout [ветка] - переключит главнЫЙ указатель HEAD на локальную ветку [ветка]
-M [HEAD -> some commit|branch|tag] $ git checkout -b [ветка] - git branch [ветка] + git checkout [ветка]
+M [HEAD -> some commit|branch|tag] $ git checkout [ветка] - переключит главнЫЙ указатель HEAD на локальную ветку [ветка] сохранив модификации если модифицируемые файлы одинаковые, ОШИБКА если модифицируемые файлы неодинаковые, срочное переключение см. -f
+M [HEAD -> some commit|branch|tag] git checkout -b [ветка] - +M git branch [ветка] + +M git checkout [ветка]
+M/-M [HEAD -> some commit|branch|tag] git checkout -B [ветка] - +M/-M git branch -f [ветка] + +M/-M git checkout [ветка]
+M/-M [HEAD -> some commit|branch|tag] git checkout -b [ветка] [commit|branch|tag] - +M/-M git branch [ветка] + +M/-M git checkout [ветка]
+M/-M [HEAD -> some commit|branch|tag] git checkout -B [ветка] [commit|branch|tag] - +M/-M git branch -f [ветка] [commit|branch|tag] + +M/-M git checkout [ветка]

+M [HEAD -> some commit|branch|tag] git checkout -f [ветка] - переключит главнЫЙ указатель HEAD на локальную ветку [ветка] удалив всякие текущие модификации файлов и удалив все что добавлено в index git (staging area)

*!!! * * * НЕ БЫВАЕТ

+M [HEAD -> some commit|branch|tag] git checkout -bf [ветка] - +M git checkout -b [ветка] + удалит всякие текущие модификации файлов и удалив все что добавлено в index git (staging area)
+M [HEAD -> some commit|branch|tag] git checkout -Bf [ветка] - +M git checkout -B [ветка] + удалит всякие текущие модификации файлов и удалив все что добавлено в index git (staging area)

Переключение на удаленные ветки

	!!! КАК ВЫЙДЕТ !!! если нет локальной ветки с именем [имя удаленной ветки]
[HEAD -> some commit|branch|tag] git checkout [имя удаленной ветки] - создаст локальную ветку с именем [имя удаленной ветки] которая будет отслеживать [имя ссылки на удаленный репозитория/имя удаленной ветки]
	!!! КАК НЕ ВЫЙДЕТ !!! если уже есть локальная ветка с именем [имя удаленной ветки] то переключит на локальную ветку с именем [имя удаленной ветки]
-f аналогично в зависимости от состояния +M/-M
[HEAD -> some commit|branch|tag] git checkout [имя ссылки на удаленный репозитория/имя удаленной ветки] - перейдет в DETACHED HEAD на коммит на который указывает [имя ссылки на удаленный репозитория/имя удаленной ветки]
-f аналогично в зависимости от состояния +M/-M
[HEAD -> some commit|branch|tag] git checkout -b [ветка] [имя ссылки на удаленный репозитория/имя удаленной ветки] = git branch [ветка] [имя ссылки на удаленный репозитория/имя удаленной ветки] + git checkout [ветка] - создаст локалную ветку с именем [ветка] которая будет отслеживать [имя ссылки на удаленный репозитория/имя удаленной ветки] и сразу же переключит HEAD на эту новосозданную ветку
-B аналогично в зависимости от состояния +M/-M
[HEAD -> some commit|branch|tag] git checkout --track [имя ссылки на удаленный репозитория/имя удаленной ветки] = git branch [имя локак как у удаленной ветки] [имя ссылки на удаленный репозитория/имя удаленной ветки] + git checkout [имя локак как у удаленной ветки] - создаст локалную ветку с именем [ветка] которая будет отслеживать [имя ссылки на удаленный репозитория/имя удаленной ветки] и сразу же переключит HEAD на эту новосозданную ветку


*!!! * * * НЕ ВЫЙДЕТ КАК НАДО

[HEAD -> some commit|branch|tag] git checkout -b [имя ссылки на удаленный репозитория/имя удаленной ветки] - создаст локальную ветку на текущей позиции [HEAD -> some commit|branch|tag] с именем [имя ссылки на удаленный репозитория/имя удаленной ветки] и наё переключит
[HEAD -> some commit|branch|tag] git checkout -b [ветка] [имя удаленной ветки] - ошибка, гит не счиает в серьёз [имя удаленной ветки] и думает что её нет
-B аналогично в зависимости от состояния +M/-M
	
Важная секция git merge

БЫВАЕТ ТОЛЬКО С ОДНИМ ПАРАМЕТРОМ ВЕТКИ, нельзя сделать [ветка] $ merge [ветка] [ветка], только [ветка] $ merge [ветка]

***
***если мы СЛИЯЕМ ветки из двух разных репозиториев в одну (два разные указателя на ссылки на удаленные репозитории) - то мы получим ЗАПРЕТ НА СЛИЯНИЕ разных историй
***
*** - для такого кроссрепозиторийного слияния нужно использовать --allow-unrelated-histories

 
[текущ локал ветка = любое имя = HEAD] $ git merge origin/[имя удаленной ветки] - МОЖНО слить в [текущ локал ветка = HEAD] удаленную ветку origin/[имя удаленной ветки] после fetch origin
	Если вам требуется собственная копия ветки serverfix , достаточно создать ее, взяв за основу удаленную ветку:
$ git checkout -b serverfix origin/serverfix ===>>> [текущ локал ветка = serverfix = HEAD] $ git merge origin/serverfix
	В результате вы получаете для работы локальную ветку, которая начинается там же, где и ветка origin/serverfix 

		Для обращения к существующей ветке наблюдения есть сокращенные формы @{upstream} или @{u}. 
		К примеру, если из ветки master вы следите за веткой origin/master, 
		для краткости можно писать git merge @{u} вместо git merge origin/master 



Важная секция git pull

	* * * если текущая ветка отслеживает удаленную
[текущ локал ветка = HEAD] $ git pull = git fetch [удаленн сервер отслеживаемый текущ локал ветка = HEAD] + git merge [удаленн сервер отслеживаемый текущ локал ветка = HEAD]/[удаленная ветка что отслеживается]
		следующий pull на этой ветке может быть без агрументов если только не удалить отслеживание	

	Если же у вас есть ветка, настроенная на слежение за какой-то удаленной веткой (подробно эта операция рассматривается в главе 3), 
	команда git pull будет автоматически извлекать информацию из удаленной ветки и выполнять слияние с текущей веткой. 
	В некоторых случаях такой порядок вещей оказывается проще и удобнее; кроме того, по умолчанию команда git clone автоматически
	настраивает вашу локальную ветку master на слежение за удаленной веткой master (она может иметь и другое имя) на сервере, с которого вы выполняли
	клонирование. В общем случае команда git pull извлекает данные с сервера, который вы клонировали, и автоматически пытается слить их с вашим текущим рабочим кодом.

[текущ локал ветка = HEAD] $ git pull origin branch --rebase -- скачает и сделает локальными новые удаленные коммиты с удаленного репозитория и поставит origin/branch - на вершину как в удаленном репозитории, но новые локальные коммиты перебазирует поверх новых скаченных с удаленного репозитория
	если КОММИТЫ локальные новые были с --allow-empty - то перебазирование их просто сотрет! если новые локальные коммиты были пусты, то указатель локальной ветки сравняется с указателем удаленной ветки 

Важная секция pull request

НЕЛЬЗЯ ОЧИСТИТЬ РЕПОЗИТОРИЙ ни на сайте ни локально!

НЕЛЬЗЯ УДАЛИТЬ ВЕТКУ репозитория по умолчанию локально!

pull request в чужой проект делается ТОЛЬКО С ФОРКА на ГИТХАБЕ!

Любая новая ветка будет гореть на гитхабе пока не будет слита в любую другую негорящую!

Я ОСТАНОВИЛСЯ НА ПЕРЕБАЗИРОВАНИЯ МАСТЕРА ДЛЯ ОЧИСТКИ удаленки!

Важная секция rebase

перебазирование ведется только на текущей ветке, это означает что текущая ветка будет перебазирована туда куда будет указано в команде

[HEAD -> some commit|branch|tag] git rebase [some commit|branch|tag] - перебазирует [HEAD -> some commit|branch|tag] на [some commit|branch|tag]
	если на одной ветке 2 указателя, то НЕ УДАЛИТСЯ ВЕТКА для незадействованного указателя а копируется ветка задействованного указателя и перебазируется задействованный указатель на новоскопированную ветку
	

	********
	НЕЛЬЗЯ ПЕРЕБАЗИРОВАТЬ удаленную ветку, т. к. удаленные ветки не удаляются как указатели с сторого определенного коммита
	удаленная ветка при перебазировании просто скопирует коммиты что внутри неё в указанное место, если не создать на вершине пере,азированной ветки указательной новой локальной ветки, то они могут быть невидны как при DETACHED_HEAD, после перебазирования на них будет указывать только HEAD


[HEAD -> some commit|branch|tag] git rebase 1: [some commit|branch|tag] 2: [some commit|branch|tag] - перебазирует 2: [some commit|branch|tag] на 1: [some commit|branch|tag]
	если на одной ветке 2 указателя, то НЕ УДАЛИТСЯ ВЕТКА для незадействованного указателя а копируется ветка задействованного указателя и перебазируется задействованный указатель на новоскопированную ветку
> rebase origin/master lamaster = > rebase lamaster origin/master - переключит lamaster напозицию origin/master

[HEAD -> some commit|branch|tag] > git rebase --onto 1: [some commit|branch|tag] 2: [some commit|branch|tag] [3: [some commit|branch|tag]] = > перебазирование [HEAD -> some commit|branch|tag] на 1: [some commit|branch|tag] начиная с позиции 2: [some commit|branch|tag] [переключившись (checkout) на 3: [some commit|branch|tag]]

[HEAD -> some commit|branch|tag] > git cherry-pick [some commit|branch|tag]..[some commit|branch|tag] - перебазирование на ветку [HEAD -> some commit|branch|tag] диапазона коммитов Ниже: [some commit|branch|tag]..[some commit|branch|tag] :выше без потери указателя ветки [some commit|branch|tag], но потом надо будет переключить указатель [some commit|branch|tag] на уже перебазированное состояние [HEAD -> some commit|branch|tag]



   E---F---G---H---I---J  topicA
then the command

git rebase --onto topicA~5 topicA~3 topicA
would result in the removal of commits F and G:

    E---H'---I'---J'  topicA






git clean -f - очистит на коммите с репозитория все лишнии файлы если мы их туда предварительно закиним

git reset --hard @~
git push origin +branch -- отресетит на удаленке неверный коммит = git push origin +branch:branch
